3.1 GET Requests 

http는 우리가 서버와 통신하는 방법이다. 일종의 프로토콜이다.
http requset는 웹사이트에 접속하고 서버에 정보를 보내는 방법이다.
우리가 서버에 접속하면 브라우저는 자동으로 서버에게 웹사이트를 request 한다. 우리는 브라우저에게 홈페이지를 가져다 달라고 요청을 한다.
우리가 웹사이트에 다가가는 게 아니라 브라우저거 우리에게 웹사이트를 제동하는 것이다.
    
    .listen 메소드를 통해서 우리는 서버를 실행시킨다.
    app.listen("${PORT}", 함수); => 첫번째 파라미터로 우리의 서버의 port을 설정한다.

                                    두번째 파라미터로 우리의 서버가 작동할 때 실행될 함수를 설정한다.


3.2 GET Requests part Two 

우리는 app.get이라는 방법을 통해서 
    브라우저가 보낸 request에 대해서 우리의 server가 response을 하고 있다.
    app.get("${페이지 주소}", 함수); => 의 방식으로 사용한다.


#3.3 Responses 

app.get을 통해서 부른 함수는 첫번째 인자로  request를 가지며 두번째 인자로는 response을 가진다.
인자를 쓰려면 두 개를 써놓아야 한다.

만약 애플리케이션이 request를 받는다면 반드시 respone을 해야한다.
respone.end =  (res.end) 를 리턴하면 브라우저가  request를 요청하는 것을 종료한다 => 페이지가 더 이상  로딩을 하지 않는다.
respone.send =  (res.send) 를 리턴하면 브라우저가 하는 request에 다양한 방법으로 응답을 한다.

app.get("/" (${request, respone})=> )

#3.5 Middlewares part One

middlewaeares는 중간에 있는 소프트웨어이다.
middlewaeares는 작업을 다음 함수에 넘기는 함수이다. 응답하는 함수가 아니다.

모든 handler(controller)는 middlewaere이고 모든 middlewares는 handler(controller)이다.

~사실 .get 메소드는 request, response 말고 next라는 파라미터를 하나 더 준다.
next()는 함수이다.
get 메소드에 argument로 넣어준 함수의 다음 argument 함수를 호출한다.
마지막 middleware은 return을 하고 .get을 종료한다.

Object ${request}
.url
요청 받은 홈페이지의 라우터를 표시한다.

#3.6 Middlewares part Two

use() 메소드는 글로벌 middleware을 만들어준다. -> .use 는 middleware을 쓰게 해주는 methode다이다. .get은 path에 도착했을 때 respone를 해주기 워한 methode다
app.use()는 app.get()보다 먼저 선언되야한다.

use() 메소드는 자동적으로 실행되며 use 메소드 끼리도 코딩순서에 따라서 동작순서도 달라진다.
use() 메소드는 필연적으로 안에 next() 함수를 호출해야한다.

그렇지 않으면 글로벌 미들웨어는 더 이상 다음 함수를 호출하지 않고 중지할 것이다.

.get() 과 .use() 두 개의 메소드가 충돌할 때에는 .use()메서드가 우선순위를 가진다.
중간에 어떠힌 미들웨어가 return을 한다면 그 즉시 미들웨어가 종료된다.


#4.1 Making Our Routers

Router은 url을 그룹화 하는 방법이다. -> url에 따라 역할을 나누어 코딩 할 수 있다. = url 정리
우리의 컨트롤러와 URL의 관리를 편하게 해준다.

const ${변수명} = express.Routers();
app.use(${url},%{Router 변수}); -> "url"을 전달하지만  get이 아니라 use이다.

누군가 라우터가 선언된 url에 접근하게 하면 Router에 get() 된 컨트롤러에 접근하게 한다.

#4.2 Cleaning the Code 
파일 안에 코드가 많아지면 코드를 기준을 정해서 나눠야한다. 그렇지 않으면 오류조차 찾을 수 없게된다.

자신과 다른 파일에서 변수를 찾아 쓰고 싶다면 우선 다른 파일이 그 변수를 export 해줘야 한다.

export default ${원하는 변수명}; => default으로 설정하면 그 변수가 import의 기본 옵션으로 작동한다.
                                    또한 기본값으로 설정된 변수를 다른  파일에서 원하는 이름으로 변경해줄 수 있다.

다른 파일에 import ${변수명} from ${파일경로};


#4.3 Exports 

한 파일의 모든 변수를 다른 파일에서 쓰고 싶을 때 

export const/let ${원하는 변수} = ${초기화}; => 원하는 변수 앞에 export를 붙여준다.

변수를 사용하기를 원하는 다른 파일에 아래의 방식으로 import 해준다.
import { ${import 하길 원하는 변수명 } , ...} from ${파일 위치}; => default로 설정한 기본 값이 없어서 다른 파일에서 맘대로 이름을 바꿀 수는 없다.

#4.7 URL Parameters part One

Router.get("/:{id}", see); 여기서 ":"이 의미하는 것은 url에 변수가 들어간다는 것이다.   
                                    ":" 뒤에 오는 것은 변수로서 우리가 설정할 수 있다.
                                    또한 req.params 에 오브젝트로 들어간다.

":" 로 변수가 선언된 라우터들은 변수가 할당되지 않은 라우터들의 하단에 위치해야 한다.
왜냐하면 프로그래밍이 작동되는 순서 때문에 변수가 선언되지 않는 라우터 위에 변수가 선언된 라우터가 오면 프로그래밍이 변수로 오인하기 때문이다. 
=> 이는 같은 경로하에 존재하는 라우터의 범주 안에서 적용된다.


#4.8 URL Parameters part Two 

정규식 

Router.get("/{}", (req, res)=>{})

라우터의 url을 제한할 때 사용하는 것이 정규식이다.

/abcd => 라우터는 무족건 abcd 라는 url에 반응하여  res을 한다.
/"ab*bc" => b 와 c 사이에 얼마든지 원하는 것이 와도 된다.
/"ab+cd" => b는 얼마든지 url에 사용되도 된다.
/"ab?cd" => b는 사용해도 되고 사용하지 않아도 된다.
/"ab?(cd)f" => cd는 사용해도 되고 사용하지 않아도 되지만 cd를 따로 구분해서 쓸 수 없다.


#5.1 Configuring Pug
(const app = express();)
app.set은 express에서 다양한 설정을 추가할 수 있다. 
app.set("view engien", "pug"); => pug을 tamplate engine 으로 쓰겠다는 뜻
                                express의 view engine은 기본적으로 /views *파일 경로에 주의* 파일에서 tamplate을 찾는다.

~> pug 사용법 

1. 기본적으로 모든 문자는 소문자로 작성한다.
2. 속성이 있다면 괄호 안에 작성한다.
3. 모든 것은 부모 속성의 안쪽에 있어야 한다. 기준은 2칸 띄우거나 tap


#5.2 Partials
 app.set("view", process.cwd() + "/src/views" )는 view의 기본 옵션을 바꾸는 것이다.
                                                     현재 작업 파일을 pakage.json이 존재하는 파일에 설정하는 것이 아니라.
                                                     "view" 로 설정한 파일로 바꿔준다.

pug는 자바스크립트으로 만들기 때문에 그 안에서 자바스크립트을 지원해 준다.

#{자바스크립트 코드}를 사용하면 자바스크립트를 pug 파일 안에서 사용할 수 있다.

pug는 include를 통해서 html을 공유할 수 있다. 
include에 설정된 html이 수정되면 html을 받고 있는 다른 html도 동시에 변경점이 적용된다.



#5.3 Extending Templates

pug에서는 상속이라는 개념이 존재한다. 
부모가 가지고 있는 tamplate을 자식에게 extends 하는 개념인데

상속을 원하는 .pug에 extends ${부모 퍼그의 주소}을 입력하면 된다.

하지만 단순히 상속에 의지하면 페이지가 부모와 같아 지는 데 이때 block이라는 개념으로 자식만의 페이지를 만들 수 있다.

block #{자신이 설정하고 싶은 이름} 을 html에서 원하는 위치에 설정한다. => 물론 부모의 tamplate 에 설정해야 한다.

부모 tamplate (block을 설정) == > 자식 tamplate (block을 사용)  --- 자식과 부모의 관계에서 block 을 사용가능

blcok ${content}            == > block content
                                    ${원하는 태그} ${원하는 설정값}


#5.4 Variables to Templates

우리는 페이지에 따라 다른 내용을 전하기 위해서 block을 썼다.
하지만 block 안에도 중복되는 것들이 있다. 이런 변수들을 페이지마다 다르게 설정할 수 있는 방법이 없을까?

방법은 tamplate 에서 변수를 설정하는 것이다.

base.pug 안에 변수를 생성해서 쓸수 있다.
다음은 변수를 설정하는 방법이다.

title #{pageTitle} | Wetube => #{변수명}이 변수가 설정된 영역이다.

그러면 이러한 변수을 초기화 할려면 어떻게 해야할 까?

그건 이 tamplate을 rendering 하는 controller에 가야한다. 
다음은 home tamplate을 rendering 하는 함수이다. 


.render은 두 가지 인자를 가진다. 처음에는 render할 템플릿을 설장하는 인자이고 두번째는 tamplate에 변술를 전달한 object을 기다리는 인자이다.

const trending = (req, res) => res.render("home", ${변수명: 초기값}); 

각 rendering 함수마다 다르게 변수를 주면 다양하게 설정할 수 있으며 Oject에 원하는 변수 아무거나 넣어도 된다.


#5.7 Conditionals 
pug에서는 render에서 설정한 변수를 간단하게 넣을 수 있는 기능을 제공하고 있다.

${태그}= ${변수명} => 태그에서 "#{}"을 쓸 필요없이 바로 변수를 사용가능하다.

pug은 조건문을 지원한다. 

                    if fakeUser.loggenIn => 조건이 false일 때 발동한다. true 면 넘어간다.
                        li 
                            a(href="/users/logout") Log Out 
                    else 
                        li 
                            a(href="/login") Log In

다만 조건문에서 상세한 조건을 설정할 수 없고 변수가 "Boolean" 값을 가지고 있어야 한다.


#5.8 Iteration
Iteration이란 rendering 과정에서 받은 배열을 pug에서 처리할 때 사용한다는 개념이다.

일단 사용을 원하는 태그 안에 설정한다

each ${변수명} in ${rendering 과정에서 전달 받은 Array}
그리고 변수명을 통해서 배열에 접근하면 쉽게 사용할 수 있다.

        each video in videos => 바로 배열을 만들어도 된다. each video in [1, 2, 3, 4]
            li=video => 굳이 li 가 아니라도 다른 태그를 사용하면 length만큼 만들어준다.

pug 은 받은 Array에 값이 있는 지 없는 지 자동으로 체크하는 데 
만약 Array에 아무것도 없는 상황을 가정하고 싶으면 else을 쓰면 된다.

        each video in videos 
            li=video
        else 
            li Here is nothing

pug 가 받은 Array에 우리는 Object을 넣을 수도 있다.
Object 안에 있는 값들은 우리가 선언한 변수에서 접근 할 수 있다.

        each video in videos 
            li=video.title => 우리가 설정한 변수 video에 .title로 접근 할 수 있다.
        else 
            li Here is nothing

#5.9 Mixins 

Mixins는 똑똑한 Partials 이다.
html을 return 해주는 일종의 함수. => html의 재사용을 돕는다. 

#{변수} 처럼 rendering 과정에서 Arrays을 받을 수 있는 Partials을 말한다.

mixin ${변수명}(${rendering 과정에서 받을 Arrays}) => "mixin"은 mixin을 사용하기 위해서 반드시 먼저 선언해야 한다.

mixin  ${사용할 배열명}(${들어올 배열명})                                 ==>  include mixins/video.pug  => mixin을 써주기 위해서 다른 Partials처럼 include 해야한다.
    div                                                 block content    
        h4=${사용할 변수명}.title                                       h2 Welcom here you well see trending videos
        ul                                                      each ${배열명} in videos 
        li #{${사용할 변수명}.rating}/5.                           +${mixin 이름}(${배열명}) 
            li #{${사용할 변수명}.Comment}/ comments.           else 
li Posted #{${사용할 변수명}.creatAt}.                             li Here is nothing
            li #{${사용할 변수명}.view} views.



#6.0 Array Database part One

pug의 고유 #{변수} 시스템은 pug의 텍스트 상에서는 잘 작동하지만 css나 html의 속성에서는 작동하지 않는다.

req.params 는 url에서 ":${변수}" 을 이용해 변수로 할당한 부분의 ${변수}를 배열로 반환해 준다.
이를 이용해 다양한 url을 설정할 수 있다.

ternary operator 

일컨데 자바의 삼항 연산자.
#{${삼항 연산자}} 로 if의 역할을 대신해 줄 수 있다.

video.views === 1 ? true : false

absolute url 과 relative url의 차이점

absolute url : 앞에 연산자 "/"을 써주면 절대 경로로 날라감 root/~~ => 내가 어디에 위치하든 간에

http://localhost:4000/{가고 싶은 위치}

relative url : 앞에 아무것도 붙여주지 않으면 root/${현재위치}/${가고 싶은 위치} => 단 변수로 설정된 url은 변수가 가고 싶은 url로 적용된다.


http://localhost:4000/videos/{가고 싶은 위치}



#6.2 Edit Video part One (11:52)

form<html> 의 속성인 method는 back end와 서버와의 데이터 전송방식이다.

GET request 와 POST request의 차이점.

GET request는 단지 데이터를 받을 때 사용한다. => input의 결과가 보인다.
POST request는 파일을 보내거나 Database에 있는 값을 바꾸기 위해서 사용된다. 웹사이트에 로그인 할 때도 쓰인다. => input의 결과가 보이지 않는다.


videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit); ===   videoRouter.get("/:id(\\d+)/edit", getEdit);
                                                                        videoRouter.post("/:id(\\d+)/edit", postEdit);


res.redirect(${우리가 보내길 원하는 경로}) => redirect을 통해서 우리가 원하는 경로로 보낼 수가 있다.  

req.body 는 form 안의 value의 javascript representation이다.

우리가 사용할 form<html>을 applicaion에게 이해시켜주기 위해서는 express미들웨어를 사용해야 한다.
app.use(express.urlencoded({ extended: "true" }))  => server.js 에 입력해서 이 미들웨어를 사용한다.

const { title } = req.body; => "express.urlencoded"을 사용한 후에 req.body로 form에서 작성한 데이터에 접근 할 수 있다.


#6.7 Introduction to MongoDB

https://docs.mongodb.com/manual/installation/ => 몽고 db 설치 하는 곳.

#6.8 Connecting to Mongo => 본 커맨드는 cmd 에서 쓴다.

cmd에서 실행이 안되면 환경 변수 path에 .lib을 등록시키면 된다.

mongo => run application

help => 커맨드 목록
show db => 몽고 db 안 보기

mongoose 을 이용한 mongo.db 연결 

import { mongoose } from "mongoose";  => Import

mongoose.connect("mongodb://127.0.0.1:27017/${Database's name}); => connet to our Application
우리가 mongoDB을 쓸 수 있게 
=> server.js에 db.js(mongoose)을 연결한다.

-> server.js
import "./db";

mongoose.connect("mongodb://127.0.0.1:27017/wetube", {
  useNewUrlParser: true,  => 나도 모르는 경고로 인해서 추가
  useUnifiedTopology: true, => 나도 모르는 경고로 인해서 추가
});  

Event 

on => 등록된 이벤트를 여러번 발생시킬 수 있다.
once => 등록된 이벤트를 한번만 발생시킨다. 


#6.9 CRUD Introduction (06:15)

Create
Read
Update
Delete 

=> CRUD

model은 데이터 베이스에게 넘겨줄 자료의 형태를 정하는 것이다.
데이터 베이스는 데이터가 어떻게 생겼는 지 model을 알아야 한다.

#6.10 Video Model

모델을 만들기 전에 모델의 형태를 정해줄 필요가 있다. => schema(Table)

mongoose.Schema=> new를 사용해 schema 객체를 만들 때 사용한다. => model을 만들기 전에 schema을 만들어야 한다.
생성자 안에 {}를 만들고 파라미터와 타입을 지정해 준다.

=>   const videoSchema = new mongoose.Schema({
  title: String,
  description: String, // === {type = String}
  createAt: Date,
  hashtags: [{ type: String }],
  meta: {
    views: Number,
    rating: Number,
  },
});

그리고 mongoose.model("${model의 이름}", ${스키마의 이름});으로 model을 설정해 주고 변수 안에 값을 저장한다.

=>   const movieModel = mongoose.model("Video", videoSchema);

model을 사용하기 위해서는 video.js을 db에 인식시켜야 한다 => 그래서 서버js에 import 함

#6.11 Our First Query

mongoose 는 jap 처럼 간편한 Query 메소드를 제공한다. => https://mongoosejs.com/docs/queries.html


${model}.find({${검색}, ${collback(err, ${documents})}}) => 검색 조건에 아무것도 적지 않으면 모든 파일을 찾는 다는 것을 의미한다.
                                                        => documents은 우리가 찾은 데이터를 의미한다.



#6.13 Async Await

promis는 collback의 최신 버전이다. => promis는 해당 funciton가 asynchronous(async) 일 때 그 함수 안에서 사용이 가능하다.


async(비동기) -- await(수행될 때까지 기다려준다)

export const home = async (req, res) => {   
  const videos = await Video.find({});   => await 키워드는 collback을 필요로 하지 않다는 것을 알려준다. 때문에 찾은 비디오를 바로 리턴 해준다.
                                            또한 await 키워드는 collback이 아님에도 데이터 베이스를 기다려준다. => await가 있다면 키워드 선언된 바로 뒤 메소드가 끝날 때까지 기다려 준다.
  return res.render("home", { pageTitle: "Home", videos });
  
};

#6.15 Creating a Video part One

database에 저장하기 위한 model을 만들기 위해서는 우리가 만든 schema을 통해서 인스턴스를 생성해 줘야 한다.


첫번째

export const postUpload = async (req, res) => {
  const { title, description, hashtags } = req.body;
  const video = new Video({          => 객체을 생성하고 
    title,
    description,
    createAt: Date.now(),
    hashtags: hashtags.split(",").map((word) => `#${word}`),
    meta: {
      views: 0,
      rating: 0,
    },
  });
  await video.save();              => 객체를 저장한다.
  return res.redirect("/");
};

두번째

export const postUpload = async (req, res) => {      
  const { title, description, hashtags } = req.body;
  await Video.create({    => 바로 create을 통해서 생성하자마자 만들어준다.
    title,
    description,
    createAt: Date.now(),
    hashtags: hashtags.split(",").map((word) => `#${word}`),
    meta: {
      views: 0,
      rating: 0,
    },
  });
  return res.redirect("/");
};

파리미터에 id가 없어도 mongoose가 자동으로   id을 준다.


#6.16 Creating a Video part Two

model로 생성돤 video 는 mongoose 의 도움을 받아서  db에 저장될 수 있는데 
.save() 메소드의 도움을 받는다.  => save 는 promis이다 때문에 async와 await가 필요하다.

mongo keward 

show dbs => 사용하고 있는 db을 보여준다.
use ${db} => db을 사용한다 
show collections => 설정한 modele들을  보여준다.
 db.videos.find() => 저장하고 있는 data을 보여준다.

 걍 MongoDBCompass을 이용하자


model

model 에서 데이터의 값을 required로 설정할 수 있다.
createAt: { type: Date, required: true }

model 에서 default값을 아예 설정해줄 수 도 있다.

createAt: { type: Date, required: true, default: Date.now } 다만 함수를 실행시키면 안된다. => collback처럼


#6.18 More Schema

model을 만드는 단계에서 data의 설정을 구체화 할수록 오류가 적어지고 요구하는 코드의 양이 줄어든다.
https://mongoosejs.com/docs/schematypes.html => model을 설정하는 단계에서 schema을 설정하는 법을 설명하고 있다.


maxLength, minLength 로 글자 수를 제한하려면 html에서 minlength 와 maxlength 을 설정해주는 것이 좋다. => 보안을 위해서


#6.19 Video Detail


https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Regular_Expressions => 정규 표현식
https://docs.mongodb.com/manual/reference/method/ObjectId/ => 


#6.20 Edit Video part One 
  join() = > array 안에 저장된 value들을 String으로 만들어준다.




#6.21 Edit Video part Two

first 
  =>  const video = await Video.findById(id);  => 변경할 비디로을 찾고 
      const title = title;                                                }
      const description = description;                                    } => 직접 model애 접근해서 값을 변경해 주고
      const hashtags = hashtags.split(",").map((word) => `#${word}`);     }
      await video.save();                      => .save()을 이용한다.
  => .map((word) => (word.startsWith("#") ? word : `#${word}`))
      이렇게 하면 # 이 있는 지 없는 지에 따러서 #을 선택해서 넣어줄 수 있다.

second
      Video.create({}) => 을 이용해서 모델에 맞게 입력하면 데이터 베이스를 생성헐 수 있다.
      await Video.create({
      title,
      description,
      hashtags: hashtags
        .split(",")
        .map((word) => (word.startsWith("#") ? word : `#${word}`)),
    });

#6.22 Edit Video part Three 

 .findOne => 조건을 설정해서 검색
  =>
 .findById => 아이디을 통해서 검색
  =>
 .findByIdAndUpdate => 아이디를 통해서 검색한 후 업데이트
=> 
await Video.findByIdAndUpdate(id, {
      title,
      description,
      hashtags: hashtags
        .split(",")
        .map((word) => (word.startsWith("#") ? word : `#${word}`)),
    });


Video.exists({ ${찾으려는 속성}: ${우리가 입력한 속성}}) => 두 값의 매칭으로 우리가 원하는 값이 존재하는 지 아닌지 검색해 준다.
                                                      => 리턴값은 boolean이다.
                                                      => 조건은 우리가 원하는 대로 사용할 수 있다.


Middlewares => mongoose에도 있는 개념이며 데이터를 처리하기 전에 미리해야 할 것을 저장하고 있다.        

#6.23 Middlewares

Middlewares 는

Validate      }
save          }
remove        }  => 에 작동하게 설계되어있다.
UpdateOne     } 
deleteOne     }
init          }

mongoose에서 Middlewares는 model이 정의되기 전에 설정해야 한다. 



=> const Video = mongoose.model("Video", videoSchema);  이거 전에 와야한다.

${스키마 이름}.pre(${행동 ex save...}, async funciton(){  => 이 함수는 this 키워드를 가지는 데 그 것은 우리가 정보를 입력한 모델이다.

})

const videoSchema = new mongoose.Schema({  => 우리가 스키마로 설정한 변수에 middlewaeare을 입력해야 한다.
  title: { type: String, required: true, trim: true, minLength: 10 },
});


#6.24 Statics


${설정한 schema 이름}.static("${정적 함수로 설정할 함수 이름}", function (parmeter) { ${함수로 설정할 부분} })

const Video = mongoose.model("Video", videoSchema);

사용 => 설정한 schema 의 이름으로 접근한 model에서 
        ${model 이름}.${정적 함수}();


#6.26 Search part One

우리는 .find() 함수로 받은 배열을 우리가 원하는 방법으로 정렬할 수 있다. => .sort({${기준으로 할 속성}: ${정렬방법}});
                                                                                                    정렬방법 => desc(내림차순), asc(오름차순)

post 방식의 form => req.body

get 방식의 form => req.query 


#6.27 Search part Two

first 
  => await video.find({
    title : keward,
  })


=> .find() + Regular_Expressions
   검색 옵션으로 find 안에 넣을 수 있다.
   .find({
     title : {
     $regex: new RegExp(정규표현식, "${설정}")  => 정규표현식에 키워드만 넣어도 검색엔진이 활성화 된다.
     $gt: ${숫자}   => great then의 약자 숫자보다 큰 값을 찾아서 넣어준다.
       
     }
   })

   => 정규표현식 `${  ${정규 표현식}   }`

더 많은 옵션 보기 
[정규표현식]
https://www.regexpal.com

[몽고DB regex]
https://docs.mongodb.com/manual/reference/operator/query/regex

[RegExp mdn]
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp